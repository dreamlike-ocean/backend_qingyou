### 基本配置

以下的所有配置都得写在一个自己定义的配置xml里面，xml开头得带有如下

```xml-dtd
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
```

这里先列举一些配置标签，之后会详细讲解

* 根标签：

  * <configuration>：核心根标签，所有的配置都得在这个标签下面

* 引入连接配置文件：

  * <properties>： 引入数据库连接配置文件标签

    * resource：属性，指定配置文件名

    ```xml-dtd
    <properties resource="jdbc.properties"/>
    ```

* 调整设置

  * <settings>：可以改变 Mybatis 运行时行为

* 起别名：

  * <typeAliases>：为全类名起别名的父标签

    * <typeAlias>：为全类名起别名的子标签
      * type：指定全类名      
      * alias：指定别名

    * <package>：为指定包下所有类起别名的子标签，别名就是类名，首字母小写

    ```xml-dtd
    <!--起别名-->
    <typeAliases>
    	<typeAlias type="com.example.springmvclearn.entity.User" alias="User"/><!--注册单个-->
    	<package name="com.example.springmvclearn.entity"/><!--注册所有-->
    		<!--二选一-->
    </typeAliase>
    ```

  * 自带别名：

    | 别名    | 数据类型          |
    | ------- | ----------------- |
    | string  | java.lang.String  |
    | long    | java.lang.Lang    |
    | int     | java.lang.Integer |
    | double  | java.lang.Double  |
    | boolean | java.lang.Boolean |
    | ....    | ......            |



* 配置环境，可以配置多个标签
  * <environments>：配置数据库环境标签，default 属性指定哪个 environment
  * <environment>：配置数据库环境子标签，id 属性是唯一标识，与 default 对应
  * <transactionManager>：事务管理标签，type 属性默认 JDBC 事务
  * <dataSoure>：数据源标签
    * type 属性：POOLED 使用连接池（MyBatis 内置），UNPOOLED 不使用连接池
  * <property>：数据库连接信息标签。
    * name 属性取值：driver，url，username，password
    * value 属性取值：与 name 对应
* 引入映射配置文件

  * <mappers>：引入映射配置文件标签
  * <mapper>：引入映射配置文件子标签
    * resource：属性指定映射配置文件的名称
    * url：引用网路路径或者磁盘路径下的 sql 映射文件
    * class：指定映射配置类
  * <package>：批量注册

#### 类型处理器（typeHandlers）

MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器。

这里摘自官网的一些举例：

| 类型处理器                   | Java 类型                      | JDBC 类型                            |
| :--------------------------- | :----------------------------- | :----------------------------------- |
| `BooleanTypeHandler`         | `java.lang.Boolean`, `boolean` | 数据库兼容的 `BOOLEAN`               |
| `ByteTypeHandler`            | `java.lang.Byte`, `byte`       | 数据库兼容的 `NUMERIC` 或 `BYTE`     |
| `ShortTypeHandler`           | `java.lang.Short`, `short`     | 数据库兼容的 `NUMERIC` 或 `SMALLINT` |
| `IntegerTypeHandler`         | `java.lang.Integer`, `int`     | 数据库兼容的 `NUMERIC` 或 `INTEGER`  |
| `LongTypeHandler`            | `java.lang.Long`, `long`       | 数据库兼容的 `NUMERIC` 或 `BIGINT`   |
| `FloatTypeHandler`           | `java.lang.Float`, `float`     | 数据库兼容的 `NUMERIC` 或 `FLOAT`    |
| `DoubleTypeHandler`          | `java.lang.Double`, `double`   | 数据库兼容的 `NUMERIC` 或 `DOUBLE`   |
| `BigDecimalTypeHandler`      | `java.math.BigDecimal`         | 数据库兼容的 `NUMERIC` 或 `DECIMAL`  |
| `StringTypeHandler`          | `java.lang.String`             | `CHAR`, `VARCHAR`                    |
| `ClobReaderTypeHandler`      | `java.io.Reader`               | -                                    |
| `ClobTypeHandler`            | `java.lang.String`             | `CLOB`, `LONGVARCHAR`                |
| `NStringTypeHandler`         | `java.lang.String`             | `NVARCHAR`, `NCHAR`                  |
| `NClobTypeHandler`           | `java.lang.String`             | `NCLOB`                              |
| `BlobInputStreamTypeHandler` | `java.io.InputStream`          | -                                    |
| `ByteArrayTypeHandler`       | `byte[]`                       | 数据库兼容的字节流类型               |
| `BlobTypeHandler`            | `byte[]`                       | `BLOB`, `LONGVARBINARY`              |
| `DateTypeHandler`            | `java.util.Date`               | `TIMESTAMP`                          |
| `DateOnlyTypeHandler`        | `java.util.Date`               | `DATE`                               |
| `TimeOnlyTypeHandler`        | `java.util.Date`               | `TIME`                               |
| `SqlTimestampTypeHandler`    | `java.sql.Timestamp`           | `TIMESTAMP`                          |
| `SqlDateTypeHandler`         | `java.sql.Date`                | `DATE`                               |
| `SqlTimeTypeHandler`         | `java.sql.Time`                | `TIME`                               |

在mybatis中对于这些基本类型会给我们自动适配对应的处理器，但对于其他一些我们自己定义的类型可能就不好处理了，我们可以自己定义类型处理器。比如我之前遇到的，我需要在数据库里把`varchar`类型查询出来转成我的`List<Integer>`类型（当然用resultmap的collection也可以）

对于自己定义自己的类型处理器，需要继承mybatis的`BaseTypeHandler<T>`里面有如下方法

![image-20221123111952587](assets\1.png)

而我们需要实现如下四个方法，这里的方法用于干啥已经在方法名写的很明白了

![image-20221123112418184](assets\2.png)

这里借鉴mybatisplus实现的一些架构写一个demo，有兴趣可以去看看mybatisplus里的AbstractJsonTypeHandler

```java
//这里的object可以换成自己想要转换的类型
public class MyTypeHandler extends BaseTypeHandler<Object> {

    @Override
    public void setNonNullParameter(PreparedStatement ps, int i, Object parameter, JdbcType jdbcType) throws SQLException {
        ps.setString(i, toJson(parameter));
    }

    @Override
    public Object getNullableResult(ResultSet rs, String columnName) throws SQLException {
        final String json = rs.getString(columnName);
        return !StringUtils.hasText(json) ? null : parse(json);
    }

    @Override
    public Object getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        final String json = rs.getString(columnIndex);
        return !StringUtils.hasText(json) ? null : parse(json);
    }

    @Override
    public Object getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        final String json = cs.getString(columnIndex);
        return !StringUtils.hasText(json) ? null : parse(json);
    }

    private  Object parse(String json){
        return JSON.parseObject(json, Object.class);
    }
//
    private  String toJson(Object obj){
        return JSON.toJSONString(obj);
    }
}

```

那我们自己定义的TypeHandler得用在哪里呢？来看看下面的简单例子

```xml
<resultMap type="com.example.springmvclearn.entity.User" id="User">

    <id column="id" property="id"/>
    <result column="uername" jdbcType="VARCHAR" property="username" 		                         	                                           typeHandler="com.example.springmvclearn.handler.MyTypeHandler"/>
    <result column="password" property="password"/>
</resultMap>
     <!--    这里只需要把我的typehandler对应的包名写到typeHandler=xxx即可-->
	<!-- 这里只是个举例，对于这个其实mybatis自己已经有了typeHandler-->
```

#### springboot配置mybatis

上面列出了那么多，我们先看看如何让springboot识别到我们的配置xml吧。

可以在我们的yml配置文件那么写，springboot就能自动识别到了

```yml
mybatis:
  mapper-locations: #指明mapper的位置
    - classpath:/mapper/*.xml
  config-location: classpath:/config/mybatisConfig.xml #指明配置文件位置
# 这里注意一下 mapper-locations可以有很多个，但是对于mybatis的配置文件就只有一个，所以不能那么写
#	config-location: 
#	- classpath:/config/mybatisConfig.xml 
#      ❌
```

同时呢，我们也可以直接在yml里写一些配置，聪明的idea也会给我们提示doge，比如我们之前讲到的typeAlias

```yml
mybatis:
  type-aliases-package: com.example.springmvclearn.entity
```

对于只需要简单的配置建议直接写yml里，但是如果自己有复杂的配置需求还是任然建议写个配置文件的xml。

##### classpath补充

先看张图吧，这是我将项目打成jar包之后解压的，这里由于篇幅原因，只讲讲里面的classes目录下的东西，也就是我们自己编写的文件，同时为了方便，读者可以看看自己运行之后产生的target目录里的classes目录

![image-20221129104823003](assets\3.png)

classpath其实就是我们的类路径目录，在打包的时候，我们的/src目录以及/resources目录的文件都会被打包到classes下面，这里是不是和我们之前自己编写的代码的目录很像呢？。所以classpath就是告诉我要去哪个classes目录去找，找哪里呢？/config/mybatisConfig.xml

##### 开启日志

你可以选择直接用xml配置

对于现在的springboot的自动配置只需要修改自己的配置文件即可

```yml
logging:
  level:
    com.example.springmvclearn.mapper: debug 
    #这里是具体的包名
```

开启了之后即可看到下面输出的日志

![image-20221123102831975](assets\4.png)